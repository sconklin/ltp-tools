#!/usr/bin/env python
#

from sys                                import argv, stdout
from getopt                             import getopt, GetoptError
from os                                 import path
from datetime                           import datetime
import uuid

from ktl.utils                       import stdo, error, dump
from ktl.dbg                         import Dbg

import JUnit_api as api

# Exit
#
class Exit():
    """
    If an error message has already been displayed and we want to just exit the app, this
    exception is raised.
    """
    pass

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
class Cmdline:
    """
    Handle all the command line processing for the application.
    """
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        """
        Simple helper which prints out an error message and then prints out the usage.
        """
        if e != '': error(e)
        self.usage(defaults)

    # usage
    #
    def usage(self, defaults):
        """
        Prints out the help text which explains the command line options.
        """
        stdo("    Usage:                                                                                   \n")
        stdo("        %s <Options> <log-file>                                                              \n" % defaults['app_name'])
        stdo("                                                                                             \n")
        stdo("    Options:                                                                                 \n")
        stdo("        --help           Prints this text.                                                   \n")
        stdo("                                                                                             \n")
        stdo("        --debug=<debug options>                                                              \n")
        stdo("                         Performs additional output related to the option enabled and        \n")
        stdo("                         the application defined support for the option.                     \n")
        stdo("                                                                                             \n")
        stdo("    Examples:                                                                                \n")
        stdo("        %s ltp-results.log                                                                   \n" % defaults['app_name'])

    # process
    #
    def process(self, argv):
        """
        This method is responsible for calling the getopt function to process the command
        line. All parameters are processed into class variables for use by other methods.
        """
        cfg = {}
        result = True
        try:
            optsShort = ''
            optsLong  = ['help', 'debug=']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif opt in ('--debug'):
                    cfg['debug'] = val.split(',')
                    for level in cfg['debug']:
                        if level not in Dbg.levels:
                            Dbg.levels.append(level)

            if result: # No errors yet

                # At lease one source package must be specified.
                #
                if len(args) > 0:
                    cfg['logs'] = args

        except GetoptError, error:
            raise CmdlineError(error)

        return cfg

# Ltp
#
class Ltp():

    # parse_header
    #
    def parse_header(self, stream):
        """
        Parse meta information about the ltp run from the first part of the
        output file. When we reach the end of the header, return what we have.
        """

        # List of items which are in the format MATCHTERM=VALUE, possibly quoted (to be stripped)
        # may not contain spaces
        equal_delimited_list = ['DISTRIB_ID', 'DISTRIB_RELEASE', 'DISTRIB_CODENAME', 'DISTRIB_DESCRIPTION']

        # List of terms which when matched at the start of the line, will include the entire rest of the line as the VALUE
        # These may contain spaces
        match_list = ['Modules Loaded']

        # TODO possibly add code to extract CPU information and amount of memory

        properties = {}
        # read until we get "Running tests......."
        for line in stream:
            if 'Running tests.......' in line:
                # we're done!
                return properties

            tag, sep, therest = line.partition('=')
            if sep != '':
                if tag in equal_delimited_list:
                    properties[tag] = therest.strip('"').strip()

            for term in match_list:
                if line.startswith(term):
                    lt = len(term)
                    properties[term.replace(' ', '_')] = line[lt:].strip()

        raise ValueError('EOF Before end of header')
        # create some data indicating a major failure
        # TODO

    # output_log_to_dict
    #
    def output_log_to_JUnit(self, stream):
        Dbg.enter("Ltp.output_log_to_JUnit")

        ts = api.testsuite(name='Ubuntu LTP tests')
        # get the properties we want from the log before we parse any tests
        props = self.parse_header(stream)

        properties = api.propertiesType()
        for key, val in props.items():
            tp = api.propertyType(key, val)
            properties.add_property(tp)
        ts.set_properties(properties)

        ts.timestamp = ''
        ts.hostname = '' # use 'localhost' if we don't know

        # iterate over all test results in the log

        ts.failures = 0
        ts.errors = 0
        ts.time = 99
        ts.tests = 99
        return ts

# LtpLogFilter
#
class LtpLogFilter():
    # initialize
    #
    def initialize(self):
        """
        A separate initialize that we can control when it gets called (not
        when the object is instantiated).
        """
        defaults = {}                   # A dictionary of application defaults
        defaults['app_name'] = argv[0]  # Used if an exception is thrown processing the command line (in the usage)
        defaults['logs'] = []

        try:
            # Process the command line arguments, and any configuration file options. Make sure
            # that any required parameters have been provided.
            #
            cmdline = Cmdline()
            self.cfg = cmdline.process(argv)
            self.verify_options(self.cfg)

        except CmdlineError as e:
            self.cmdline.error(e.msg, defaults)
            raise Exit()

        return

    # verify_options
    #
    def verify_options(self, cfg):
        """
        Used to verify that all required parameters are present and correct.
        """
        retval = False

        # At least one log file is required.
        #
        if len(cfg['logs']) == 0:
            CmdlineError("At least one log file must be specified.")

        for fid in cfg['logs']:
            if not path.exists(fid):
                error("The log file (%s) does not exist." % (fid))
                raise Exit

        return

    # main
    #
    def main(self):
        try:
            self.initialize()

            ltp = Ltp()
            testsuites = api.testsuites()
            for fid in self.cfg['logs']:
                with open(fid, 'r') as f:
                    ts = ltp.output_log_to_JUnit(f)
                    testsuites.add_testsuite(ts)
            testsuites.export(stdout, 0)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        except Exit:
            pass

        return

if __name__ == '__main__':
    app = LtpLogFilter()
    app.main()

# vi:set ts=4 sw=4 expandtab:

